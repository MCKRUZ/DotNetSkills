#!/usr/bin/env python3
"""
API Client Generator Script

This script generates strongly-typed API clients from OpenAPI specifications.
It can be integrated into build pipelines or run manually.

Usage:
    python generate-client.py --spec openapi.json --output ./Generated --namespace Api.Client

Requirements:
    pip install pyyaml jinja2
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Any, Dict, List

# Template for model classes
MODEL_TEMPLATE = '''// <auto-generated/>
#nullable enable

namespace {namespace}.Models;

/// <summary>
/// {description}
/// </summary>
public record {name}
{{
{properties}
}}
'''

# Template for property
PROPERTY_TEMPLATE = '''    /// <summary>
    /// {description}
    /// </summary>
    public {type} {name} {{ get; init; }}{default}
'''


def load_spec(spec_path: str) -> Dict[str, Any]:
    """Load OpenAPI specification from file."""
    with open(spec_path, 'r', encoding='utf-8') as f:
        if spec_path.endswith('.yaml') or spec_path.endswith('.yml'):
            import yaml
            return yaml.safe_load(f)
        return json.load(f)


def openapi_type_to_csharp(prop: Dict[str, Any], required: bool) -> str:
    """Convert OpenAPI type to C# type."""
    type_map = {
        'string': 'string',
        'integer': 'int',
        'number': 'double',
        'boolean': 'bool',
        'array': 'List<{items}>',
        'object': 'object',
    }

    openapi_type = prop.get('type', 'object')
    csharp_type = type_map.get(openapi_type, 'object')

    # Handle arrays
    if openapi_type == 'array':
        items = prop.get('items', {})
        item_type = openapi_type_to_csharp(items, True)
        csharp_type = f'List<{item_type}>'

    # Handle format specifiers
    format_spec = prop.get('format')
    if format_spec == 'date-time':
        csharp_type = 'DateTime'
    elif format_spec == 'uuid':
        csharp_type = 'Guid'
    elif format_spec == 'int64':
        csharp_type = 'long'

    # Handle nullable
    if not required and csharp_type not in ('string',):
        csharp_type += '?'

    return csharp_type


def generate_model(name: str, schema: Dict[str, Any], namespace: str) -> str:
    """Generate a C# model class from schema."""
    properties = schema.get('properties', {})
    required = set(schema.get('required', []))
    description = schema.get('description', f'{name} model.')

    prop_lines = []
    for prop_name, prop_def in properties.items():
        is_required = prop_name in required
        csharp_type = openapi_type_to_csharp(prop_def, is_required)
        prop_desc = prop_def.get('description', f'Gets the {prop_name}.')

        # Pascal case the property name
        pascal_name = prop_name[0].upper() + prop_name[1:]

        default = '' if is_required else ' = default!;'
        if csharp_type == 'string' and not is_required:
            default = ' = string.Empty;'

        prop_lines.append(PROPERTY_TEMPLATE.format(
            type=csharp_type,
            name=pascal_name,
            description=prop_desc,
            default=default
        ))

    return MODEL_TEMPLATE.format(
        namespace=namespace,
        name=name,
        description=description,
        properties='\n'.join(prop_lines)
    )


def main():
    parser = argparse.ArgumentParser(description='Generate API clients from OpenAPI specs')
    parser.add_argument('--spec', required=True, help='Path to OpenAPI spec file')
    parser.add_argument('--output', required=True, help='Output directory')
    parser.add_argument('--namespace', default='Api.Client', help='Root namespace')
    args = parser.parse_args()

    # Load spec
    print(f'Loading spec from {args.spec}...')
    spec = load_spec(args.spec)

    # Create output directories
    output_path = Path(args.output)
    models_path = output_path / 'Models'
    models_path.mkdir(parents=True, exist_ok=True)

    # Generate models
    schemas = spec.get('components', {}).get('schemas', {})
    print(f'Found {len(schemas)} schemas')

    for name, schema in schemas.items():
        model_code = generate_model(name, schema, args.namespace)
        model_file = models_path / f'{name}.cs'
        model_file.write_text(model_code, encoding='utf-8')
        print(f'  Generated {model_file}')

    print('Generation complete!')
    return 0


if __name__ == '__main__':
    sys.exit(main())
